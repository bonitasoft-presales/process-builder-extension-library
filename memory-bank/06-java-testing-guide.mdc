# 06-java-testing-guide.mdc: Comprehensive Java Testing Standards

## 1. Core Testing Philosophy

### 1.1. Mandatory Requirements
* **Coverage Goal:** **100% test coverage** for all Java classes - NO EXCEPTIONS
* **Assertion Library:** **AssertJ ONLY** - NEVER use JUnit native assertions
* **Framework:** JUnit 5 (Jupiter) with Mockito for mocking
* **Property Testing:** jqwik for invariant verification and security testing
* **Mutation Testing:** PIT for test quality validation (target: >80% mutation score)
* **Security Testing:** Property-based tests for CVE and vulnerability protection

### 1.2. Test Class Structure
Every class requires corresponding test classes:
* `{ClassName}Test.java` - Unit tests with Mockito
* `{ClassName}PropertyTest.java` - Property-based tests (for DTOs/Records/Enums)
* `SecurityVulnerabilityPropertyTest.java` - Security-focused property tests

---

## 2. AssertJ Assertions (MANDATORY)

### 2.1. NEVER Use JUnit Assertions
```java
// CORRECT - AssertJ
assertThat(result).isNotNull();
assertThat(result.getValue()).isEqualTo(expected);
assertThat(list).hasSize(3).contains("a", "b");
assertThatThrownBy(() -> method()).isInstanceOf(Exception.class);
assertThatCode(() -> method()).doesNotThrowAnyException();

// FORBIDDEN - JUnit assertions
assertEquals(expected, result);      // NEVER
assertTrue(condition);               // NEVER
assertNotNull(result);               // NEVER
assertThrows(Exception.class, ...);  // Use assertThatThrownBy instead
```

### 2.2. AssertJ Patterns
```java
// Collections
assertThat(list).isEmpty();
assertThat(list).hasSize(5);
assertThat(list).containsExactly("a", "b", "c");
assertThat(list).containsExactlyInAnyOrder("c", "a", "b");
assertThat(list).doesNotContain("x");

// Strings
assertThat(str).isNotBlank();
assertThat(str).startsWith("prefix");
assertThat(str).containsIgnoringCase("expected");

// Objects
assertThat(result).isInstanceOf(MyClass.class);
assertThat(result).extracting("name", "age").containsExactly("John", 30);

// Exceptions
assertThatThrownBy(() -> service.method(null))
    .isInstanceOf(IllegalArgumentException.class)
    .hasMessageContaining("must not be null");

// Optional
assertThat(optional).isPresent().contains(expectedValue);
assertThat(optional).isEmpty();
```

---

## 3. Test Class Template

### 3.1. Standard Unit Test Class
```java
package com.bonitasoft.processbuilder;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.quality.Strictness;
import org.mockito.junit.jupiter.MockitoSettings;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
@DisplayName("{ClassName} Unit Tests")
class MyClassTest {

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    private static final Long TEST_ID = 1L;
    private static final String TEST_NAME = "TestValue";

    // =========================================================================
    // MOCKS AND TEST SUBJECT
    // =========================================================================

    @Mock
    private DependencyClass dependency;

    @InjectMocks
    private MyClass underTest;

    @Captor
    private ArgumentCaptor<SomeOptions> optionsCaptor;

    // =========================================================================
    // CONSTRUCTOR TESTS (for utility classes)
    // =========================================================================

    @Nested
    @DisplayName("Constructor Tests")
    class ConstructorTests {

        @Test
        @DisplayName("Private constructor should prevent instantiation")
        void constructor_should_be_private() throws Exception {
            var constructor = MyUtilClass.class.getDeclaredConstructor();
            assertThat(java.lang.reflect.Modifier.isPrivate(constructor.getModifiers())).isTrue();

            constructor.setAccessible(true);
            assertThatCode(() -> constructor.newInstance()).doesNotThrowAnyException();
        }
    }

    // =========================================================================
    // METHOD TESTS (grouped by method)
    // =========================================================================

    @Nested
    @DisplayName("methodName Tests")
    class MethodNameTests {

        @Test
        @DisplayName("should return expected result when valid input")
        void should_return_expected_when_valid_input() {
            // Arrange (Given)
            when(dependency.getData()).thenReturn("data");

            // Act (When)
            var result = underTest.methodName(TEST_ID);

            // Assert (Then)
            assertThat(result).isNotNull();
            assertThat(result.getValue()).isEqualTo("expected");
            verify(dependency).getData();
        }

        @Test
        @DisplayName("should handle null input gracefully")
        void should_handle_null_input() {
            var result = underTest.methodName(null);
            assertThat(result).isNull();
        }

        @Test
        @DisplayName("should throw exception when invalid state")
        void should_throw_when_invalid() {
            assertThatThrownBy(() -> underTest.methodName(-1L))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Invalid");
        }
    }
}
```

---

## 4. Naming Conventions

### 4.1. Test Method Names
```java
// Pattern: should_expectedBehavior_when_condition
void should_return_empty_list_when_no_data_found() { }
void should_throw_exception_when_input_is_null() { }
void should_calculate_total_when_valid_items() { }

// For edge cases
void should_handle_empty_string_input() { }
void should_handle_whitespace_only_input() { }
void should_handle_max_value_boundary() { }
```

### 4.2. @DisplayName Usage
```java
@Test
@DisplayName("should return empty list when repository has no records")
void should_return_empty_list_when_no_records() { }

@Nested
@DisplayName("findById Method Tests")
class FindByIdTests { }
```

---

## 5. Coverage Requirements Checklist

### 5.1. For EVERY Public Method Test:
- [ ] Happy path (valid input returns expected output)
- [ ] Null input handling
- [ ] Empty input handling (empty string, empty list, empty map)
- [ ] Whitespace-only input (for strings)
- [ ] Boundary values (0, -1, MAX_VALUE, MIN_VALUE)
- [ ] Exception scenarios
- [ ] All if/else branches
- [ ] All switch cases
- [ ] All ternary operator paths

### 5.2. For Utility Classes:
- [ ] Private constructor test (verify it's private + coverage)
- [ ] All static methods
- [ ] All overloaded method variants

### 5.3. For Enums:
- [ ] values() length verification
- [ ] Each constant existence (name())
- [ ] Each constant's getKey() and getDescription()
- [ ] isValid() with valid, invalid, null, empty, whitespace inputs
- [ ] getAllData() returns correct map size and keys
- [ ] getAllKeysList() returns correct list size and values
- [ ] Unmodifiable collections (assertThrows on modification)

### 5.4. For Collections Returned:
- [ ] Verify immutability (assertThrows on add/remove/clear)
- [ ] Verify correct size
- [ ] Verify content presence

---

## 6. Mockito Best Practices

### 6.1. Setup Patterns
```java
// Basic mocking
when(repository.findById(TEST_ID)).thenReturn(Optional.of(entity));
when(repository.findById(INVALID_ID)).thenReturn(Optional.empty());

// Argument matchers
when(repository.findById(anyLong())).thenReturn(Optional.of(entity));
when(service.process(any(Request.class))).thenReturn(response);

// Throwing exceptions
when(service.riskyMethod()).thenThrow(new RuntimeException("Error"));
doThrow(new IOException()).when(service).voidMethod();

// Answer for complex behavior
when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
```

### 6.2. Verification Patterns
```java
// Verify called
verify(repository).findById(TEST_ID);
verify(repository, times(2)).save(any());
verify(repository, atLeastOnce()).delete(any());

// Verify never called
verify(repository, never()).delete(any());
verifyNoInteractions(repository);
verifyNoMoreInteractions(repository);

// Argument capturing
ArgumentCaptor<Entity> captor = ArgumentCaptor.forClass(Entity.class);
verify(repository).save(captor.capture());
assertThat(captor.getValue().getName()).isEqualTo("expected");
```

### 6.3. ArgumentCaptor for Complex Verifications
```java
// CRITICAL for mutation testing - verify actual arguments passed
@Captor
private ArgumentCaptor<SearchOptions> searchOptionsCaptor;

@Test
@DisplayName("should execute search with correct options")
void should_execute_search_with_options() throws Exception {
    // Given
    when(searchResult.getResult()).thenReturn(Collections.emptyList());
    when(identityAPI.searchUsers(any(SearchOptions.class))).thenReturn(searchResult);

    // When
    MyClass.searchMethod(input, identityAPI);

    // Then - verify searchUsers was called with SearchOptions
    verify(identityAPI).searchUsers(searchOptionsCaptor.capture());
    SearchOptions capturedOptions = searchOptionsCaptor.getValue();
    assertThat(capturedOptions).isNotNull();
}
```

### 6.4. Static Method Mocking
```java
@Test
void should_handle_static_method() {
    try (MockedStatic<UtilClass> mocked = mockStatic(UtilClass.class)) {
        mocked.when(() -> UtilClass.staticMethod(any()))
              .thenReturn("mocked");

        var result = underTest.methodThatUsesStatic();

        assertThat(result).isEqualTo("expected");
    }
}
```

---

## 7. Testing Specific Scenarios

### 7.1. Testing Catch Blocks
```java
@Test
@DisplayName("should handle exception gracefully")
void should_handle_exception() {
    when(dependency.riskyMethod()).thenThrow(new RuntimeException("Test"));

    // Verify catch block behavior
    var result = underTest.methodWithTryCatch();

    assertThat(result).isEqualTo(fallbackValue);
    // OR
    assertThatCode(() -> underTest.methodWithTryCatch())
        .doesNotThrowAnyException();
}
```

### 7.2. Testing Logging
```java
// Focus on behavior, not log output
@Test
void should_log_and_return_empty_when_error() {
    when(dependency.fetch()).thenThrow(new IOException());

    var result = underTest.fetchData();

    assertThat(result).isEmpty();
    // Log verification is implicit through code coverage
}
```

### 7.3. Testing Optional Returns
```java
@Test
void should_return_empty_optional_when_not_found() {
    when(repository.findById(anyLong())).thenReturn(Optional.empty());

    var result = underTest.findById(TEST_ID);

    assertThat(result).isEmpty();
}

@Test
void should_return_present_optional_when_found() {
    when(repository.findById(TEST_ID)).thenReturn(Optional.of(entity));

    var result = underTest.findById(TEST_ID);

    assertThat(result).isPresent().contains(entity);
}
```

### 7.4. Testing Streams and Lambdas
```java
@Test
void should_filter_and_map_correctly() {
    var input = List.of(
        new Item(1L, "valid"),
        new Item(null, "invalid"),
        new Item(2L, "valid2")
    );

    var result = underTest.processItems(input);

    assertThat(result)
        .hasSize(2)
        .extracting(Item::getId)
        .containsExactly(1L, 2L);
}
```

---

## 8. Property-Based Testing with jqwik

### 8.1. When to Use
* DTOs, Records, Value Objects
* Methods with mathematical properties
* Parsers and validators
* Any code with invariants
* Security vulnerability testing

### 8.2. Property Test Template
```java
package com.bonitasoft.processbuilder;

import net.jqwik.api.*;
import net.jqwik.api.constraints.*;
import org.junit.jupiter.api.DisplayName;

import static org.assertj.core.api.Assertions.*;

@DisplayName("{ClassName} Property Tests")
class MyClassPropertyTest {

    // =========================================================================
    // EQUALITY PROPERTIES
    // =========================================================================

    @Property(tries = 1000)
    @DisplayName("Equality should be reflexive: x.equals(x)")
    void equalityShouldBeReflexive(@ForAll @From("validInstances") MyClass instance) {
        assertThat(instance).isEqualTo(instance);
    }

    @Property(tries = 1000)
    @DisplayName("Equality should be symmetric: x.equals(y) == y.equals(x)")
    void equalityShouldBeSymmetric(
            @ForAll @From("validInstances") MyClass a,
            @ForAll @From("validInstances") MyClass b) {
        assertThat(a.equals(b)).isEqualTo(b.equals(a));
    }

    @Property(tries = 1000)
    @DisplayName("HashCode should be consistent with equals")
    void hashCodeConsistentWithEquals(
            @ForAll @From("validInstances") MyClass a,
            @ForAll @From("validInstances") MyClass b) {
        if (a.equals(b)) {
            assertThat(a.hashCode()).isEqualTo(b.hashCode());
        }
    }

    // =========================================================================
    // NULL SAFETY PROPERTIES
    // =========================================================================

    @Property(tries = 500)
    @DisplayName("toString should never throw")
    void toStringShouldNeverThrow(@ForAll @From("instancesWithNulls") MyClass instance) {
        assertThatCode(() -> instance.toString()).doesNotThrowAnyException();
    }

    @Property(tries = 500)
    @DisplayName("equals(null) should return false")
    void equalsNullShouldReturnFalse(@ForAll @From("validInstances") MyClass instance) {
        assertThat(instance.equals(null)).isFalse();
    }

    // =========================================================================
    // ARBITRARIES (DATA GENERATORS)
    // =========================================================================

    @Provide
    Arbitrary<MyClass> validInstances() {
        return Combinators.combine(
            Arbitraries.longs().greaterOrEqual(1L),
            Arbitraries.strings().alpha().ofMinLength(1).ofMaxLength(100)
        ).as(MyClass::new);
    }

    @Provide
    Arbitrary<MyClass> instancesWithNulls() {
        return Combinators.combine(
            Arbitraries.longs().greaterOrEqual(1L).injectNull(0.3),
            Arbitraries.strings().alpha().ofMaxLength(100).injectNull(0.3)
        ).as(MyClass::new);
    }
}
```

### 8.3. Common Arbitraries
```java
// Numbers
Arbitraries.integers()
Arbitraries.longs().greaterOrEqual(1L)
Arbitraries.doubles().between(0.0, 100.0)

// Strings
Arbitraries.strings().alpha()
Arbitraries.strings().numeric()
Arbitraries.strings().ofMinLength(1).ofMaxLength(50)

// Collections
Arbitraries.of("A", "B", "C")
Arbitraries.oneOf(arb1, arb2)
arbitrary.injectNull(0.2)  // 20% null chance

// Annotations
@ForAll @IntRange(min = 0, max = 100) int value
@ForAll @LongRange(min = 1) Long id
@ForAll @StringLength(min = 1, max = 50) String name
```

---

## 9. Mutation Testing with PIT

### 9.1. Overview
PIT (Pitest) is a mutation testing tool that measures test quality by introducing small changes (mutations) to the code and checking if tests detect them.

**Key Metrics:**
| Metric | Target | Description |
|--------|--------|-------------|
| Line Coverage | >90% | Lines executed by tests |
| Mutation Score | >80% | Percentage of mutations killed |
| Test Strength | >80% | Mutations killed / Mutations covered |

### 9.2. Running Mutation Tests
```bash
# Run mutation testing
mvn clean test pitest:mutationCoverage

# Run with stronger mutators
mvn clean test pitest:mutationCoverage -Dpitest.mutators=STRONGER

# View report
target/pit-reports/index.html
```

### 9.3. Common PIT Mutations and How to Kill Them

#### 9.3.1. Return Value Mutations
```java
// MUTATION: "replaced Long return value with 0L"
// Affects: return null; (replaced with return 0L)

// BAD TEST - doesn't distinguish null from 0L
@Test
void should_return_something() {
    Long result = method(null);
    assertThat(result).isNotEqualTo(1L);  // Passes for both null and 0L!
}

// GOOD TEST - explicitly checks for null
@Test
void should_return_null_for_null_input() {
    Long result = method(null);
    assertThat(result).isNull();  // Fails if mutation returns 0L
}
```

#### 9.3.2. Conditional Boundary Mutations
```java
// MUTATION: "changed conditional boundary" (e.g., > to >=)

// BAD TEST
@Test
void should_pass_for_positive() {
    assertThat(isPositive(5)).isTrue();  // Passes for both > 0 and >= 0
}

// GOOD TEST - test the exact boundary
@Test
void should_return_false_for_zero() {
    assertThat(isPositive(0)).isFalse();  // Kills > to >= mutation
}

@Test
void should_return_true_for_one() {
    assertThat(isPositive(1)).isTrue();   // Verifies > 0 behavior
}
```

#### 9.3.3. Negated Conditionals
```java
// MUTATION: "negated conditional" (e.g., == to !=)

// Ensure you test BOTH branches explicitly
@Test
void should_return_true_when_equal() {
    assertThat(areEqual("a", "a")).isTrue();
}

@Test
void should_return_false_when_not_equal() {
    assertThat(areEqual("a", "b")).isFalse();
}
```

#### 9.3.4. Math Operator Mutations
```java
// MUTATION: "replaced % with *" or "replaced + with -"

// BAD TEST
@Test
void should_extract_seconds() {
    assertEquals(30L, extractSeconds(150000L));  // 150 seconds
    // Both % 60 and * 60 might not catch this
}

// GOOD TESTS - verify modulo behavior specifically
@Test
void should_return_zero_for_exactly_one_minute() {
    // 60 seconds % 60 = 0, but 60 * 60 = 3600
    assertThat(extractSeconds(60000L)).isEqualTo(0L);
}

@Test
void should_return_one_for_61_seconds() {
    // 61 % 60 = 1, but 61 * 60 = 3660
    assertThat(extractSeconds(61000L)).isEqualTo(1L);
}
```

#### 9.3.5. Void Method Call Mutations
```java
// MUTATION: "removed call to method()"

// Use verify() to ensure methods are called
@Test
void should_call_logger() {
    underTest.process(input);
    verify(logger).info(anyString(), any());  // Kills "removed call" mutation
}
```

### 9.4. Testing Private Methods for Mutation Coverage

When PIT shows surviving mutations in private helper methods that are difficult to test through public API:

```java
// OPTION 1: Change private to package-private (preferred)
// In production code:
static Long extractLongValue(Object obj, String methodName) {  // Was private
    // ...
}

// In test code (same package):
@Test
@DisplayName("extractLongValue should return null for null object")
void extractLongValue_should_return_null_for_null() {
    Long result = MyClass.extractLongValue(null, "getGroupId");
    assertThat(result).isNull();  // Not 0L!
}
```

### 9.5. Mutation Testing Checklist
- [ ] Run `mvn pitest:mutationCoverage` after writing tests
- [ ] Review surviving mutations in HTML report
- [ ] For "return value with 0L" mutations: verify null returns explicitly
- [ ] For boundary mutations: test exact boundary values (0, -1, MAX_VALUE)
- [ ] For conditional mutations: test both true and false branches
- [ ] For math mutations: use values that distinguish operators (+/-, */%, etc.)
- [ ] Consider making private methods package-private for direct testing
- [ ] Use ArgumentCaptor to verify mock interactions

---

## 10. Security Property Testing

### 10.1. Purpose
Security property tests protect against vulnerabilities like:
* **CVE-2025-48924**: Uncontrolled Recursion in Apache Commons Lang
* **ReDoS**: Regular Expression Denial of Service
* **Stack Overflow**: Deep recursion attacks
* **Memory Exhaustion**: Very large input handling

### 10.2. Security Test Structure
```java
@DisplayName("Security Vulnerability Property Tests")
class SecurityVulnerabilityPropertyTest {

    private static final long MAX_EXECUTION_TIME_MS = 5000;

    /**
     * Tests that deeply nested patterns don't cause StackOverflowError.
     * Targets: CVE-2025-48924
     */
    @Property(tries = 100)
    @DisplayName("Deep recursion patterns should not cause StackOverflowError")
    void deepRecursion_shouldNotCauseStackOverflow(
            @ForAll @IntRange(min = 100, max = 5000) int depth) {

        String maliciousInput = "[".repeat(depth) + "Content" + "]".repeat(depth);

        assertThatCode(() -> {
            MyClass.processInput(maliciousInput);
        }).doesNotThrowAnyException();
    }

    /**
     * Tests that very long strings don't cause timeout or memory issues.
     */
    @Property(tries = 20)
    @DisplayName("Long strings should process within time limits")
    void longStrings_shouldProcessInTime(
            @ForAll @IntRange(min = 10000, max = 100000) int length) {

        String longInput = "a".repeat(length);
        long startTime = System.currentTimeMillis();

        assertThatCode(() -> MyClass.processInput(longInput))
            .doesNotThrowAnyException();

        long executionTime = System.currentTimeMillis() - startTime;
        assertThat(executionTime).isLessThan(MAX_EXECUTION_TIME_MS);
    }

    /**
     * Tests that special characters don't break processing.
     */
    @Property(tries = 100)
    @DisplayName("Special characters should be handled safely")
    void specialCharacters_shouldBeSafe(
            @ForAll @StringLength(min = 1, max = 1000) String input) {

        String[] dangerous = {
            input + "\u0000",          // Null byte
            "{{" + input + "}}",       // Template injection
            "${" + input + "}",        // Variable injection
        };

        for (String pattern : dangerous) {
            assertThatCode(() -> MyClass.processInput(pattern))
                .doesNotThrowAnyException();
        }
    }
}
```

### 10.3. Security Testing Patterns

| Attack Vector | Test Strategy |
|---------------|---------------|
| Deep recursion (CVE-2025-48924) | Generate deeply nested brackets/braces |
| ReDoS | Incremental string lengths with regex patterns |
| Stack overflow | Very deep nesting (1000-10000 levels) |
| Memory exhaustion | Very long strings (100K+ characters) |
| Null byte injection | Insert \u0000 into strings |
| Unicode edge cases | Surrogate pairs, BOM, RTL characters |
| Template injection | {{var}}, ${var}, <% %> patterns |

### 10.4. Time Complexity Verification
```java
@Property(tries = 50)
@DisplayName("Algorithm should have linear time complexity")
void linearComplexity_shouldBeVerified(
        @ForAll @IntRange(min = 1000, max = 50000) int length) {

    String input = "a".repeat(length);
    long startTime = System.currentTimeMillis();

    MyClass.processInput(input);

    long executionTime = System.currentTimeMillis() - startTime;

    // Linear: ~1ms per 1000 chars
    long maxExpectedTime = Math.max(100, length / 10);
    assertThat(executionTime)
        .as("Execution time should scale linearly")
        .isLessThan(maxExpectedTime);
}
```

---

## 11. QA Best Practices

### 11.1. Test Independence
* Each test must be independent - no shared mutable state
* Use `@BeforeEach` for common setup, not shared fields
* Never rely on test execution order

### 11.2. Test Data Management
```java
// Use constants for repeated values
private static final Long TEST_USER_ID = 1L;
private static final String TEST_EMAIL = "test@example.com";

// Use builder patterns for complex objects
private User createTestUser(Long id, String email) {
    return User.builder()
        .id(id)
        .email(email)
        .build();
}
```

### 11.3. Test Readability
* One assertion concept per test (but multiple assertThat calls are OK)
* Clear test names that describe the scenario
* AAA pattern: Arrange, Act, Assert (with blank lines between)
* Comments only for non-obvious setup

### 11.4. Boundary Testing
```java
// Always test boundaries
@Test void should_handle_zero() { }
@Test void should_handle_negative_one() { }
@Test void should_handle_max_value() { }
@Test void should_handle_min_value() { }
@Test void should_handle_empty_collection() { }
@Test void should_handle_single_element_collection() { }
```

### 11.5. Error Message Assertions
```java
// Verify exception messages are helpful
assertThatThrownBy(() -> service.process(null))
    .isInstanceOf(IllegalArgumentException.class)
    .hasMessageContaining("input")
    .hasMessageContaining("null");
```

---

## 12. Maven Commands

### 12.1. Standard Execution
```bash
# Full build with all reports
mvn clean install site

# Compile only (quick check)
mvn clean compile

# Tests only
mvn clean test

# Tests with coverage report
mvn clean test jacoco:report

# Mutation testing
mvn clean test pitest:mutationCoverage

# Mutation testing with stronger mutators
mvn clean test pitest:mutationCoverage -Dpitest.mutators=STRONGER
```

### 12.2. Specific Tests
```bash
# Single test class
mvn test -Dtest=MyClassTest

# Property tests only
mvn test -Dtest=*PropertyTest

# Security tests only
mvn test -Dtest=*SecurityVulnerability*

# Pattern matching
mvn test -Dtest=*Utils*Test
```

### 12.3. Reports Location
| Report | Location |
|--------|----------|
| JaCoCo Coverage | `target/site/jacoco/index.html` |
| PIT Mutation | `target/pit-reports/index.html` |
| Surefire Tests | `target/surefire-reports/` |

---

## 13. GitHub Actions Integration

### 13.1. Mutation Testing Workflow
The mutation testing workflow runs on-demand and generates a detailed summary:

```yaml
# .github/workflows/mutation.yml
name: Mutation Testing

on:
  workflow_dispatch:
    inputs:
      mutator:
        description: 'Mutator strength'
        default: 'DEFAULTS'
        type: choice
        options:
          - DEFAULTS
          - STRONGER

jobs:
  mutation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'
          cache: 'maven'
      - name: Run Mutation Testing
        run: ./mvnw clean test pitest:mutationCoverage
      - name: Upload Report
        uses: actions/upload-artifact@v4
        with:
          name: pit-mutation-report
          path: target/pit-reports/
```

### 13.2. Interpreting CI Results
- **Line Coverage <90%**: Add more unit tests
- **Mutation Score <80%**: Review surviving mutations, improve assertions
- **Test Strength <80%**: Tests are covering code but not detecting mutations

---

## 14. Pre-Commit Checklist

Before committing any code:

- [ ] All tests pass: `mvn clean test`
- [ ] Coverage is 100%: Check JaCoCo report
- [ ] Mutation score >80%: `mvn pitest:mutationCoverage`
- [ ] No PMD violations: Check site report
- [ ] No CPD duplications: Check site report
- [ ] All public methods have @DisplayName tests
- [ ] AssertJ used exclusively (no JUnit assertions)
- [ ] Naming convention followed: `should_X_when_Y`
- [ ] All branches covered (if/else/switch/ternary)
- [ ] All catch blocks tested
- [ ] Null/empty/boundary cases tested
- [ ] Security property tests pass
- [ ] Full build passes: `mvn clean install site`

---

## 15. Common Mistakes to Avoid

### 15.1. Testing Anti-Patterns
```java
// BAD: Testing implementation details
verify(repository, times(3)).save(any()); // Brittle

// GOOD: Test behavior
assertThat(result.getItems()).hasSize(3);

// BAD: Over-mocking
when(entity.getId()).thenReturn(1L);
when(entity.getName()).thenReturn("test");
// ... 20 more when() calls

// GOOD: Use real objects when simple
var entity = new Entity(1L, "test");

// BAD: No assertions
@Test void should_not_throw() {
    underTest.method(); // Where's the assertion?
}

// GOOD: Explicit assertion
@Test void should_not_throw() {
    assertThatCode(() -> underTest.method()).doesNotThrowAnyException();
}
```

### 15.2. Coverage Pitfalls
```java
// BAD: False coverage (code runs but not verified)
@Test void should_process() {
    underTest.process(input);
    // No assertion - code runs but behavior not verified
}

// GOOD: Meaningful coverage
@Test void should_process() {
    var result = underTest.process(input);
    assertThat(result.isProcessed()).isTrue();
    assertThat(result.getOutput()).isEqualTo(expected);
}
```

### 15.3. Mutation Testing Pitfalls
```java
// BAD: Doesn't distinguish null from 0L
@Test void extractValue_should_work() {
    Long result = extractValue(null, "method");
    assertThat(result).isNotEqualTo(42L);  // Both null and 0L pass!
}

// GOOD: Explicitly verify null
@Test void extractValue_should_return_null_for_null_input() {
    Long result = extractValue(null, "method");
    assertThat(result).isNull();  // Fails if mutation returns 0L
}
```

---

## 16. Quick Reference Card

### Assertions
```java
assertThat(x).isNull();
assertThat(x).isNotNull();
assertThat(x).isEqualTo(expected);
assertThat(x).isNotEqualTo(unexpected);
assertThat(list).isEmpty();
assertThat(list).hasSize(n);
assertThat(list).contains(item);
assertThat(list).containsExactly(items);
assertThat(optional).isPresent();
assertThat(optional).isEmpty();
assertThatThrownBy(() -> x).isInstanceOf(Exception.class);
assertThatCode(() -> x).doesNotThrowAnyException();
```

### Mockito
```java
when(mock.method()).thenReturn(value);
when(mock.method()).thenThrow(exception);
verify(mock).method();
verify(mock, times(n)).method();
verify(mock, never()).method();
ArgumentCaptor<T> captor = ArgumentCaptor.forClass(T.class);
verify(mock).method(captor.capture());
```

### Property Testing
```java
@Property(tries = 100)
void property(@ForAll Type value) { }

@ForAll @IntRange(min = 0, max = 100) int x
@ForAll @StringLength(min = 1, max = 50) String s
@ForAll @From("provider") Type value
```

---

**Version:** 4.0
**Last Updated:** 2025-12-21
**Scope:** Java unit testing, property-based testing, mutation testing, security testing
