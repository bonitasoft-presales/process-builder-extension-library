package com.bonitasoft.processbuilder.security;

import com.bonitasoft.processbuilder.extension.PBStringUtils;
import com.bonitasoft.processbuilder.extension.InputValidationUtils;
import com.bonitasoft.processbuilder.extension.StorageUtils;
import com.bonitasoft.processbuilder.validation.JsonSchemaValidator;
import net.jqwik.api.*;
import net.jqwik.api.constraints.*;

import static org.assertj.core.api.Assertions.*;

/**
 * Security-focused Property Tests to protect against common vulnerabilities.
 * <p>
 * This test suite specifically targets:
 * <ul>
 *   <li><b>CVE-2025-48924</b>: Uncontrolled Recursion in Apache Commons Lang ClassUtils.getClass</li>
 *   <li><b>ReDoS</b>: Regular Expression Denial of Service attacks</li>
 *   <li><b>Stack Overflow</b>: Deep recursion and excessive nesting attacks</li>
 *   <li><b>Memory Exhaustion</b>: Very large input handling</li>
 * </ul>
 * </p>
 * <p>
 * These tests ensure the application handles malicious or malformed input gracefully
 * without crashing, hanging, or consuming excessive resources.
 * </p>
 *
 * @author Bonitasoft Security Team
 * @since 1.0
 * @see <a href="https://nvd.nist.gov/vuln/detail/CVE-2025-48924">CVE-2025-48924</a>
 */
@Label("Security Vulnerability Property Tests")
class SecurityVulnerabilityPropertyTest {

    // =========================================================================
    // CONSTANTS FOR SECURITY TESTING
    // =========================================================================

    /** Maximum execution time for any operation (prevents infinite loops) */
    private static final long MAX_EXECUTION_TIME_MS = 5000;

    // =========================================================================
    // CVE-2025-48924: UNCONTROLLED RECURSION TESTS
    // =========================================================================

    /**
     * Tests that deeply nested array bracket patterns don't cause StackOverflowError.
     * <p>
     * CVE-2025-48924 affects ClassUtils.getClass() when processing class names with
     * deeply nested array brackets like "[[[[[[[...".
     * </p>
     */
    @Property(tries = 100)
    @Label("Deep array bracket patterns should not cause StackOverflowError")
    void deepArrayBrackets_shouldNotCauseStackOverflow(
            @ForAll @IntRange(min = 100, max = 5000) int depth) {

        // Generate deeply nested array bracket pattern (simulating CVE-2025-48924 attack vector)
        String maliciousInput = "[".repeat(depth) + "Ljava.lang.String;" + "]".repeat(depth);

        // Verify string operations don't crash
        assertThatCode(() -> {
            PBStringUtils.normalizeTitleCase(maliciousInput);
            PBStringUtils.toLowerSnakeCase(maliciousInput);
            PBStringUtils.toUpperSnakeCase(maliciousInput);
        }).doesNotThrowAnyException();
    }

    /**
     * Tests that deeply nested curly brace patterns are handled safely.
     * Targets potential recursion in JSON/template processing.
     */
    @Property(tries = 100)
    @Label("Deep curly brace nesting should not cause StackOverflowError")
    void deepCurlyBraces_shouldNotCauseStackOverflow(
            @ForAll @IntRange(min = 100, max = 5000) int depth) {

        // Generate deeply nested template pattern
        String maliciousInput = "{{".repeat(depth) + "var:name" + "}}".repeat(depth);

        assertThatCode(() -> {
            PBStringUtils.resolveTemplateVariables(maliciousInput, (ref, data) -> "safe");
        }).doesNotThrowAnyException();
    }

    /**
     * Tests recursive class name patterns that could exploit ClassUtils.getClass().
     */
    @Property(tries = 50)
    @Label("Recursive class-like patterns should be handled safely")
    void recursiveClassPatterns_shouldBeSafe(
            @ForAll @IntRange(min = 10, max = 1000) int repetitions) {

        // Patterns similar to what CVE-2025-48924 exploits
        String[] maliciousPatterns = {
            "[[[[L" + "a.".repeat(repetitions) + "Class;",
            "[L" + "[L".repeat(repetitions) + "java.lang.Object;",
            "L" + "[[".repeat(repetitions) + "I;",
            "$".repeat(repetitions) + "InnerClass",
            "java.lang." + "Object$".repeat(Math.min(repetitions, 100))
        };

        for (String pattern : maliciousPatterns) {
            assertThatCode(() -> {
                // Test our string utilities don't crash
                PBStringUtils.normalizeTitleCase(pattern);
                PBStringUtils.toLowerSnakeCase(pattern);
                PBStringUtils.toUpperSnakeCase(pattern);
            }).doesNotThrowAnyException();
        }
    }

    // =========================================================================
    // STRING LENGTH ATTACK RESILIENCE
    // =========================================================================

    /**
     * Tests that extremely long strings don't cause OutOfMemoryError or excessive latency.
     */
    @Property(tries = 20)
    @Label("Very long strings should be processed within time limits")
    void veryLongStrings_shouldProcessWithinTimeLimits(
            @ForAll @IntRange(min = 10000, max = 100000) int length) {

        String longString = "a".repeat(length);
        long startTime = System.currentTimeMillis();

        assertThatCode(() -> {
            PBStringUtils.normalizeTitleCase(longString);
            PBStringUtils.toLowerSnakeCase(longString);
            PBStringUtils.toUpperSnakeCase(longString);
        }).doesNotThrowAnyException();

        long executionTime = System.currentTimeMillis() - startTime;
        assertThat(executionTime)
            .as("Operation should complete within %dms", MAX_EXECUTION_TIME_MS)
            .isLessThan(MAX_EXECUTION_TIME_MS);
    }

    /**
     * Tests incremental string lengths to detect algorithmic complexity attacks (ReDoS).
     */
    @Property(tries = 50)
    @Label("Incremental string lengths should have linear time complexity")
    void incrementalStringLengths_shouldHaveLinearComplexity(
            @ForAll @IntRange(min = 1000, max = 50000) int length) {

        // Pattern that could trigger ReDoS in regex-based operations
        String potentialReDoSPattern = "a".repeat(length) + "!";

        long startTime = System.currentTimeMillis();

        assertThatCode(() -> {
            // Template resolution uses regex
            PBStringUtils.resolveTemplateVariables(potentialReDoSPattern, (ref, data) -> "x");
        }).doesNotThrowAnyException();

        long executionTime = System.currentTimeMillis() - startTime;

        // Linear complexity check: time should scale linearly with input size
        // Allow 1ms per 1000 characters as a rough baseline
        long maxExpectedTime = Math.max(100, length / 10);
        assertThat(executionTime)
            .as("ReDoS check: execution time should scale linearly")
            .isLessThan(maxExpectedTime);
    }

    // =========================================================================
    // SPECIAL CHARACTER INJECTION TESTS
    // =========================================================================

    /**
     * Tests that null bytes and control characters don't break processing.
     */
    @Property(tries = 100)
    @Label("Null bytes and control characters should be handled safely")
    void nullBytesAndControlChars_shouldBeHandledSafely(
            @ForAll @StringLength(min = 1, max = 1000) String base,
            @ForAll @IntRange(min = 0, max = 31) int controlChar) {

        // Inject control character into string
        String maliciousInput = base + ((char) controlChar) + base;

        assertThatCode(() -> {
            PBStringUtils.normalizeTitleCase(maliciousInput);
            PBStringUtils.toLowerSnakeCase(maliciousInput);
            PBStringUtils.toUpperSnakeCase(maliciousInput);
        }).doesNotThrowAnyException();
    }

    /**
     * Tests Unicode edge cases including surrogate pairs.
     */
    @Property(tries = 100)
    @Label("Unicode edge cases should not cause exceptions")
    void unicodeEdgeCases_shouldNotCauseExceptions(
            @ForAll @IntRange(min = 1, max = 100) int repetitions) {

        String[] unicodePatterns = {
            "\uD800\uDC00".repeat(repetitions),  // Valid surrogate pair
            "\uFFFF".repeat(repetitions),         // Non-character
            "\u0000".repeat(repetitions),         // Null character
            "\u200B".repeat(repetitions),         // Zero-width space
            "\uFEFF".repeat(repetitions),         // BOM
            "\u202E".repeat(repetitions)          // Right-to-left override
        };

        for (String pattern : unicodePatterns) {
            assertThatCode(() -> {
                PBStringUtils.normalizeTitleCase(pattern);
                PBStringUtils.toLowerSnakeCase(pattern);
                PBStringUtils.toUpperSnakeCase(pattern);
            }).doesNotThrowAnyException();
        }
    }

    // =========================================================================
    // JSON/TEMPLATE INJECTION TESTS
    // =========================================================================

    /**
     * Tests that JSON-like injection patterns don't break template processing.
     */
    @Property(tries = 100)
    @Label("JSON injection patterns should not break template resolution")
    void jsonInjection_shouldNotBreakTemplates(
            @ForAll @StringLength(min = 1, max = 100) String userInput) {

        String[] injectionPatterns = {
            "{\"malicious\": \"" + userInput + "\"}",
            "{{" + userInput + "}}",
            "{{ref:" + userInput + "}}",
            "${" + userInput + "}",
            "<%= " + userInput + " %>"
        };

        for (String pattern : injectionPatterns) {
            assertThatCode(() -> {
                PBStringUtils.resolveTemplateVariables(pattern, (ref, data) -> "SAFE_VALUE");
            }).doesNotThrowAnyException();
        }
    }

    /**
     * Tests nested template patterns that could cause infinite loops.
     */
    @Property(tries = 50)
    @Label("Nested template patterns should terminate")
    void nestedTemplates_shouldTerminate(
            @ForAll @IntRange(min = 1, max = 100) int nestingDepth) {

        // Build nested pattern like {{ref1:{{ref2:{{ref3:data}}}}}}
        StringBuilder nested = new StringBuilder();
        for (int i = 0; i < nestingDepth; i++) {
            nested.append("{{ref").append(i).append(":");
        }
        nested.append("data");
        for (int i = 0; i < nestingDepth; i++) {
            nested.append("}}");
        }

        String nestedPattern = nested.toString();
        long startTime = System.currentTimeMillis();

        assertThatCode(() -> {
            PBStringUtils.resolveTemplateVariables(nestedPattern, (ref, data) -> "value");
        }).doesNotThrowAnyException();

        long executionTime = System.currentTimeMillis() - startTime;
        assertThat(executionTime)
            .as("Nested template processing should complete quickly")
            .isLessThan(1000);
    }

    // =========================================================================
    // INPUT VALIDATION SECURITY TESTS
    // =========================================================================

    /**
     * Tests that InputValidationUtils handles malicious input safely.
     */
    @Property(tries = 100)
    @Label("Input validation should handle malicious patterns safely")
    void inputValidation_shouldHandleMaliciousPatterns(
            @ForAll @StringLength(min = 0, max = 10000) String input) {

        assertThatCode(() -> {
            // These methods should handle any input without throwing unexpected exceptions
            InputValidationUtils.parseStringToPositiveLong(input, "testParam");
            InputValidationUtils.parseStringToLong(input, "testParam");
        }).doesNotThrowAnyException();
    }

    /**
     * Tests storage key validation with malicious input.
     */
    @Property(tries = 100)
    @Label("Storage validation should handle malicious keys safely")
    void storageValidation_shouldHandleMaliciousKeys(
            @ForAll @StringLength(min = 0, max = 1000) String key) {

        assertThatCode(() -> {
            StorageUtils.isBonitaStorage(key);
            StorageUtils.isLocalStorage(key);
        }).doesNotThrowAnyException();
    }

    // =========================================================================
    // STACK OVERFLOW SPECIFIC TESTS
    // =========================================================================

    /**
     * Tests that recursive-looking patterns don't trigger stack overflow.
     * This specifically targets CVE-2025-48924 style attacks.
     */
    @Property(tries = 20)
    @Label("Recursive patterns should not cause StackOverflowError")
    void recursivePatterns_shouldNotCauseStackOverflow(
            @ForAll @IntRange(min = 1000, max = 10000) int depth) {

        // Pattern that mimics deeply nested array type descriptors
        String recursivePattern = "[".repeat(depth);

        assertThatCode(() -> {
            try {
                PBStringUtils.normalizeTitleCase(recursivePattern);
                PBStringUtils.toLowerSnakeCase(recursivePattern);
                PBStringUtils.toUpperSnakeCase(recursivePattern);
            } catch (StackOverflowError e) {
                fail("StackOverflowError should not occur with depth " + depth);
            }
        }).doesNotThrowAnyException();
    }

    /**
     * Tests exponentially growing patterns to ensure no algorithmic explosion.
     */
    @Property(tries = 10)
    @Label("Exponential patterns should be handled in bounded time")
    void exponentialPatterns_shouldBeBounded(
            @ForAll @IntRange(min = 5, max = 20) int exponent) {

        // Pattern that could cause exponential blowup in naive implementations
        int size = (int) Math.pow(2, exponent);
        String exponentialPattern = "a".repeat(Math.min(size, 100000));

        long startTime = System.currentTimeMillis();

        assertThatCode(() -> {
            PBStringUtils.normalizeTitleCase(exponentialPattern);
        }).doesNotThrowAnyException();

        long executionTime = System.currentTimeMillis() - startTime;
        assertThat(executionTime)
            .as("Exponential pattern handling should be bounded")
            .isLessThan(MAX_EXECUTION_TIME_MS);
    }

    // =========================================================================
    // JSON SCHEMA VALIDATOR SECURITY TESTS
    // =========================================================================

    /**
     * Tests that JSON schema validator handles malicious input gracefully.
     */
    @Property(tries = 50)
    @Label("JSON schema validator should handle malicious JSON safely")
    void jsonSchemaValidator_shouldHandleMaliciousJson(
            @ForAll @StringLength(min = 0, max = 1000) String maliciousContent) {

        String[] maliciousJsons = {
            "{" + "\"a\":{".repeat(100) + "\"x\":1" + "}".repeat(100) + "}",  // Deep nesting
            "[" + "[".repeat(100) + "1" + "]".repeat(100) + "]",              // Deep array
            "{\"key\":\"" + maliciousContent.replace("\"", "\\\"") + "\"}",  // Escaped content
            "null",
            "\"" + "a".repeat(10000) + "\"",                                   // Long string
            "{}"
        };

        for (String json : maliciousJsons) {
            assertThatCode(() -> {
                // Should return false gracefully, not throw or hang
                JsonSchemaValidator.isJsonValidForType("INSERT", "TestType", json);
            }).doesNotThrowAnyException();
        }
    }

    // =========================================================================
    // ARBITRARIES (DATA GENERATORS)
    // =========================================================================

    /**
     * Generates potentially malicious class name patterns.
     */
    @Provide
    Arbitrary<String> maliciousClassNames() {
        return Arbitraries.oneOf(
            Arbitraries.integers().between(1, 100).map(n -> "[".repeat(n) + "I"),
            Arbitraries.integers().between(1, 100).map(n -> "L" + "a.".repeat(n) + "Class;"),
            Arbitraries.integers().between(1, 50).map(n -> "$".repeat(n) + "Inner"),
            Arbitraries.strings().alpha().ofMinLength(1).ofMaxLength(50)
                .map(s -> "[[L" + s + ";")
        );
    }

    /**
     * Generates potentially dangerous special character sequences.
     */
    @Provide
    Arbitrary<String> dangerousSequences() {
        return Arbitraries.oneOf(
            Arbitraries.just("\u0000"),           // Null byte
            Arbitraries.just("\r\n"),             // CRLF injection
            Arbitraries.just("{{"),               // Template start
            Arbitraries.just("}}"),               // Template end
            Arbitraries.just("${"),               // Variable injection
            Arbitraries.just("<%"),               // Script injection
            Arbitraries.strings().withChars('\u0000', '\u001F')  // Control chars
                .ofMinLength(1).ofMaxLength(10)
        );
    }
}
